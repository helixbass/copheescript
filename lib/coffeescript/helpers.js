// Generated by CoffeeScript 2.3.1
(function() {
  // This file contains the common helper functions that we'd like to share among
  // the **Lexer**, **Rewriter**, and the **Nodes**. Merge objects, flatten
  // arrays, count characters, that sort of thing.
  // Peek at the beginning of a given string to see if it matches a sequence.
  var UNICODE_CODE_POINT_ESCAPE, attachCommentsToNode, buildLocationData, buildLocationHash, buildTokenDataDictionary, dump, expandLocationDataToInclude, extend, flatten, isBoolean, isFunction, isNumber, isPlainObject, isString, isToken, locationFields, mergeBabylonLocationData, ref, repeat, syntaxErrorToString, traverseBabylonAst, traverseBabylonAsts, unicodeCodePointToUnicodeEscapes,
    splice = [].splice,
    indexOf = [].indexOf,
    hasProp = {}.hasOwnProperty;

  exports.starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  // Peek at the end of a given string to see if it matches a sequence.
  exports.ends = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  // Repeat a string `n` times.
  exports.repeat = repeat = function(str, n) {
    var res;
    // Use clever algorithm to have O(log(n)) string concatenation operations.
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  // Trim out all falsy values from an array.
  exports.compact = function(array) {
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      item = array[i];
      if (item) {
        results.push(item);
      }
    }
    return results;
  };

  // Count the number of occurrences of a string in a string.
  exports.count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  // Merge objects, returning a fresh copy with attributes from both sides.
  // Used every time `Base#compile` is called, to allow properties in the
  // options hash to propagate down the tree without polluting other branches.
  exports.merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  // Extend a source object with the properties of another object (shallow copy).
  extend = exports.extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  // Return a flattened version of an array.
  // Handy for getting a list of `children` from the nodes.
  exports.flatten = flatten = function(array) {
    var element, flattened, i, len1;
    flattened = [];
    for (i = 0, len1 = array.length; i < len1; i++) {
      element = array[i];
      if ('[object Array]' === Object.prototype.toString.call(element)) {
        flattened = flattened.concat(flatten(element));
      } else {
        flattened.push(element);
      }
    }
    return flattened;
  };

  // Delete a key from an object, returning the value. Useful when a node is
  // looking for a particular method in an options hash.
  exports.del = function(obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  // Typical Array::some
  exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {
    var e, i, len1, ref1;
    ref1 = this;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      e = ref1[i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  // Helper function for extracting code from Literate CoffeeScript by stripping
  // out all non-code blocks, producing a string of CoffeeScript code that can
  // be compiled “normally.”
  exports.invertLiterate = function(code) {
    var blankLine, i, indented, insideComment, len1, line, listItemStart, out, ref1;
    out = [];
    blankLine = /^\s*$/;
    indented = /^[\t ]/;
    listItemStart = /^(?:\t?| {0,3})(?:[\*\-\+]|[0-9]{1,9}\.)[ \t]/; // Up to one tab, or up to three spaces, or neither;
    // followed by `*`, `-` or `+`;
    // or by an integer up to 9 digits long, followed by a period;
    // followed by a space or a tab.
    insideComment = false;
    ref1 = code.split('\n');
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      line = ref1[i];
      if (blankLine.test(line)) {
        insideComment = false;
        out.push(line);
      } else if (insideComment || listItemStart.test(line)) {
        insideComment = true;
        out.push(`# ${line}`);
      } else if (!insideComment && indented.test(line)) {
        out.push(line);
      } else {
        insideComment = true;
        out.push(`# ${line}`);
      }
    }
    return out.join('\n');
  };

  // Merge two jison-style location data objects together.
  // If `last` is not provided, this will simply return `first`.
  buildLocationData = function(first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column,
        range: [first.range[0], last.range[1]]
      };
    }
  };

  buildLocationHash = function(loc) {
    return `${loc.first_line}x${loc.first_column}-${loc.last_line}x${loc.last_column}`;
  };

  // Build a dictionary of extra token properties organized by tokens’ locations
  // used as lookup hashes.
  buildTokenDataDictionary = function(parserState) {
    var base1, i, len1, ref1, token, tokenData, tokenHash;
    tokenData = {};
    ref1 = parserState.parser.tokens;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      token = ref1[i];
      if (!token.comments) {
        continue;
      }
      tokenHash = buildLocationHash(token[2]);
      // Multiple tokens might have the same location hash, such as the generated
      // `JS` tokens added at the start or end of the token stream to hold
      // comments that start or end a file.
      if (tokenData[tokenHash] == null) {
        tokenData[tokenHash] = {};
      }
      if (token.comments) { // `comments` is always an array.
        // For “overlapping” tokens, that is tokens with the same location data
        // and therefore matching `tokenHash`es, merge the comments from both/all
        // tokens together into one array, even if there are duplicate comments;
        // they will get sorted out later.
        ((base1 = tokenData[tokenHash]).comments != null ? base1.comments : base1.comments = []).push(...token.comments);
      }
    }
    return tokenData;
  };

  // This returns a function which takes an object as a parameter, and if that
  // object is an AST node, updates that object's locationData.
  // The object is returned either way.
  exports.addDataToNode = function(parserState, first, last, {forceUpdateLocation} = {}) {
    return function(obj) {
      var objHash, ref1;
      // Add location data.
      if (first != null) {
        if ((obj != null ? obj.updateLocationDataIfMissing : void 0) != null) {
          obj.updateLocationDataIfMissing(buildLocationData(first, last), {
            force: forceUpdateLocation
          });
        // This is only necessary to try and "preserve" JSX tag location data
        } else if (Array.isArray(obj)) {
          obj.locationData = buildLocationData(first, last);
          obj.openingBracketLocationData = buildLocationData(first);
          obj.closingBracketLocationData = buildLocationData(last); // if last?
        }
      }
      // Add comments, building the dictionary of token data if it hasn’t been
      // built yet.
      if (parserState.tokenData == null) {
        parserState.tokenData = buildTokenDataDictionary(parserState);
      }
      if (obj.locationData != null) {
        objHash = buildLocationHash(obj.locationData);
        if (((ref1 = parserState.tokenData[objHash]) != null ? ref1.comments : void 0) != null) {
          attachCommentsToNode(parserState.tokenData[objHash].comments, obj);
        }
      }
      return obj;
    };
  };

  isToken = function(obj) {
    return ("2" in obj) && ("first_line" in obj[2]);
  };

  expandLocationDataToInclude = function(existing, addtl) {
    var end, first_column, first_line, last_column, last_line, start;
    if (!(existing && addtl)) {
      return;
    }
    ({
      range: [start, end],
      first_line,
      first_column,
      last_line,
      last_column
    } = existing);
    if (addtl.range[0] < start) {
      existing.range[0] = addtl.range[0];
      existing.first_line = addtl.first_line;
      existing.first_column = addtl.first_column;
    }
    if (addtl.range[1] > end) {
      existing.range[1] = addtl.range[1];
      existing.last_line = addtl.last_line;
      return (existing.last_column = addtl.last_column);
    }
  };

  exports.attachCommentsToNode = attachCommentsToNode = function(comments, node) {
    var _isToken, comment, i, len1, results;
    if ((comments == null) || comments.length === 0) {
      return;
    }
    if (node.comments == null) {
      node.comments = [];
    }
    _isToken = isToken(node);
    results = [];
    for (i = 0, len1 = comments.length; i < len1; i++) {
      comment = comments[i];
      // expandLocationDataToInclude node[2], comment.locationData if _isToken
      results.push(node.comments.push(comment));
    }
    return results;
  };

  // Convert jison location data to a string.
  // `obj` can be a token, or a locationData.
  exports.locationDataToString = function(obj) {
    var locationData;
    if (isToken(obj)) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return `${locationData.first_line + 1}:${locationData.first_column + 1}-` + `${locationData.last_line + 1}:${locationData.last_column + 1}`;
    } else {
      return "No location data";
    }
  };

  // A `.coffee.md` compatible version of `basename`, that returns the file sans-extension.
  exports.baseFileName = function(file, stripExt = false, useWinPathSep = false) {
    var parts, pathSep;
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  // Determine if a filename represents a CoffeeScript file.
  exports.isCoffee = function(file) {
    return /\.((lit)?coffee|coffee\.md)$/.test(file);
  };

  // Determine if a filename represents a Literate CoffeeScript file.
  exports.isLiterate = function(file) {
    return /\.(litcoffee|coffee\.md)$/.test(file);
  };

  // Throws a SyntaxError from a given location.
  // The error's `toString` will return an error message following the "standard"
  // format `<filename>:<line>:<col>: <message>` plus the line with the error and a
  // marker showing where the error is.
  exports.throwSyntaxError = function(message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    // Instead of showing the compiler's stacktrace, show our custom error message
    // (this is useful when the error bubbles up in Node.js applications that
    // compile CoffeeScript for example).
    error.stack = error.toString();
    throw error;
  };

  // Update a compiler SyntaxError with source code information if it didn't have
  // it already.
  exports.updateSyntaxError = function(error, code, filename) {
    // Avoid screwing up the `stack` property of other errors (i.e. possible bugs).
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };

  syntaxErrorToString = function() {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, start;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    ({first_line, first_column, last_line, last_column} = this.location);
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    filename = this.filename || '[stdin]';
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    // Show only the first line on multi-line errors.
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    // Check to see if we're running on a color-enabled TTY.
    if (typeof process !== "undefined" && process !== null) {
      colorsEnabled = ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) && !((ref2 = process.env) != null ? ref2.NODE_DISABLE_COLORS : void 0);
    }
    if ((ref3 = this.colorful) != null ? ref3 : colorsEnabled) {
      colorize = function(str) {
        return `\x1B[1;31m${str}\x1B[0m`;
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return `${filename}:${first_line + 1}:${first_column + 1}: error: ${this.message}\n${codeLine}\n${marker}`;
  };

  exports.nameWhitespaceCharacter = function(string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };

  exports.locationDataToBabel = function({first_line, first_column, last_line, last_column, range}) {
    return {
      loc: {
        start: {
          line: first_line + 1,
          column: first_column
        },
        end: {
          line: last_line + 1,
          column: last_column + 1
        }
      },
      range: [range[0], range[1]],
      start: range[0],
      end: range[1]
    };
  };

  exports.babelLocationFields = locationFields = ['loc', 'range', 'start', 'end'];

  exports.isFunction = isFunction = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };

  exports.isNumber = isNumber = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Number]';
  };

  exports.isString = isString = function(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
  };

  exports.isBoolean = isBoolean = function(obj) {
    return obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';
  };

  exports.isPlainObject = isPlainObject = function(obj) {
    return typeof obj === 'object' && !!obj && !Array.isArray(obj) && !isNumber(obj) && !isString(obj) && !isBoolean(obj);
  };

  // Converts a number, string, or node (Value/NumberLiteral/unary +/- Op) to its
  // corresponding number value.
  exports.getNumberValue = function(number) {
    var base, invert, val;
    if (isNumber(number)) {
      return number;
    }
    invert = false;
    if (!isString(number)) {
      number = (function() {
        number = number.unwrap();
        if (number.operator) {
          if (number.operator === '-') {
            invert = true;
          }
          return number.first.unwrap().value;
        } else {
          return number.value;
        }
      })();
    }
    base = (function() {
      switch (number.charAt(1)) {
        case 'b':
          return 2;
        case 'o':
          return 8;
        case 'x':
          return 16;
        default:
          return null;
      }
    })();
    val = base != null ? parseInt(number.slice(2), base) : parseFloat(number);
    if (!invert) {
      return val;
    }
    return val * -1;
  };

  exports.dump = dump = function(...args) {
    var obj, ref1, util;
    ref1 = args, [...args] = ref1, [obj] = splice.call(args, -1);
    util = require('util');
    return console.log(...args, util.inspect(obj, false, null));
  };

  exports.mergeBabylonLocationData = mergeBabylonLocationData = function(intoNode, fromNode) {
    var fromItem, fromRange, i, intoRange, len1;
    if (Array.isArray(fromNode)) {
      for (i = 0, len1 = fromNode.length; i < len1; i++) {
        fromItem = fromNode[i];
        mergeBabylonLocationData(intoNode, fromItem);
      }
      return intoNode;
    }
    ({
      range: intoRange
    } = intoNode);
    ({
      range: fromRange
    } = fromNode);
    if (!(intoRange && fromRange)) { // TODO: should figure out why don't have location data?
      return intoNode;
    }
    if (fromRange[0] < intoRange[0]) {
      intoRange[0] = fromRange[0];
      intoNode.start = fromNode.start;
      intoNode.loc.start = fromNode.loc.start;
    }
    if (fromRange[1] > intoRange[1]) {
      intoRange[1] = fromRange[1];
      intoNode.end = fromNode.end;
      intoNode.loc.end = fromNode.loc.end;
    }
    return intoNode;
  };

  exports.mergeLocationData = function(intoNode, fromNode) {
    var fromLocationData, fromRange, intoLocationData, intoRange;
    ({
      locationData: intoLocationData
    } = intoNode);
    ({
      locationData: fromLocationData
    } = fromNode);
    ({
      range: intoRange
    } = intoLocationData);
    ({
      range: fromRange
    } = fromLocationData);
    if (!(intoRange && fromRange)) { // TODO: should figure out why don't have location data?
      return intoNode;
    }
    if (fromRange[0] < intoRange[0]) {
      intoLocationData = intoNode.locationData = {...intoLocationData};
      intoLocationData.range = [fromRange[0], intoRange[1]];
      intoLocationData.first_line = fromLocationData.first_line;
      intoLocationData.first_column = fromLocationData.first_column;
    }
    if (fromRange[1] > intoRange[1]) {
      intoLocationData = intoNode.locationData = {...intoLocationData};
      intoLocationData.range = [intoRange[0], fromRange[1]];
      intoLocationData.last_line = fromLocationData.last_line;
      intoLocationData.last_column = fromLocationData.last_column;
    }
    return intoNode;
  };

  exports.assignEmptyTrailingLocationData = function(intoNode, fromNode) {
    var fromLocationData, fromRange;
    ({
      locationData: fromLocationData
    } = fromNode);
    ({
      range: fromRange
    } = fromLocationData);
    intoNode.locationData = {
      range: [fromRange[1] + 1, fromRange[1]],
      first_line: fromLocationData.last_line,
      first_column: fromLocationData.last_column + 1, // TODO: refine?
      last_line: fromLocationData.last_line,
      last_column: fromLocationData.last_column + 1
    };
    return intoNode;
  };

  exports.mapValues = function(obj, fn) {
    return Object.keys(obj).reduce(function(result, key) {
      result[key] = fn(obj[key], key);
      return result;
    }, {});
  };

  exports.traverseBabylonAst = traverseBabylonAst = function(node, func, {skipSelf, skip, parent, key} = {}) {
    var _key, child, childRet, i, index, indexesToRemove, item, j, len1, len2, ret;
    // if skipSelf
    //   skip = [node]
    //   if skipSelf.and
    //     skip.push skipSelf.and...
    if (Array.isArray(node)) {
      indexesToRemove = [];
      for (index = i = 0, len1 = node.length; i < len1; index = ++i) {
        item = node[index];
        ret = traverseBabylonAst(item, func, {skip, parent, key});
        if (ret === 'REMOVE') {
          indexesToRemove.unshift(index);
        }
      }
      for (j = 0, len2 = indexesToRemove.length; j < len2; j++) {
        index = indexesToRemove[j];
        node.splice(index, 1);
      }
      return;
    }
    if ((node != null) && !(skip && indexOf.call(skip, node) >= 0)) {
      ret = func(node, {skip, parent, key});
    }
    if (ret === 'STOP') {
      return;
    }
    if (isPlainObject(node)) {
      for (_key in node) {
        if (!hasProp.call(node, _key)) continue;
        child = node[_key];
        if (!(indexOf.call(locationFields, _key) < 0)) {
          continue;
        }
        childRet = traverseBabylonAst(child, func, {
          skip,
          parent: node,
          key: _key
        });
        if (childRet === 'REMOVE') {
          node[_key] = null;
        }
      }
    }
    return ret;
  };

  exports.traverseBabylonAsts = traverseBabylonAsts = function(node, correspondingNode, func) {
    var child, index, item, key, results;
    if (Array.isArray(node)) {
      if (!Array.isArray(correspondingNode)) {
        return;
      }
      return (function() {
        var i, len1, results;
        results = [];
        for (index = i = 0, len1 = node.length; i < len1; index = ++i) {
          item = node[index];
          results.push(traverseBabylonAsts(item, correspondingNode[index], func));
        }
        return results;
      })();
    }
    func(node, correspondingNode);
    if (isPlainObject(node)) {
      if (!isPlainObject(correspondingNode)) {
        return;
      }
      results = [];
      for (key in node) {
        if (!hasProp.call(node, key)) continue;
        child = node[key];
        if (indexOf.call(locationFields, key) < 0) {
          results.push(traverseBabylonAsts(child, correspondingNode[key], func));
        }
      }
      return results;
    }
  };

  // Constructs a string or regex by escaping certain characters.
  exports.makeDelimitedLiteral = function(body, options = {}) {
    var regex;
    if (body === '' && options.delimiter === '/') {
      body = '(?:)';
    }
    regex = RegExp(`(\\\\\\\\)|(\\\\0(?=[1-7]))|\\\\?(${options.delimiter})|\\\\?(?:(\\n)|(\\r)|(\\u2028)|(\\u2029))|(\\\\.)`, "g");
    // Escaped backslash.
    // Null character mistaken as octal escape.
    // (Possibly escaped) delimiter.
    // (Possibly escaped) newlines.
    // Other escapes.
    body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {
      switch (false) {
        // Ignore escaped backslashes.
        case !backslash:
          if (options.double) {
            return backslash + backslash;
          } else {
            return backslash;
          }
        case !nul:
          return '\\x00';
        case !delimiter:
          return `\\${delimiter}`;
        case !lf:
          return '\\n';
        case !cr:
          return '\\r';
        case !ls:
          return '\\u2028';
        case !ps:
          return '\\u2029';
        case !other:
          if (options.double) {
            return `\\${other}`;
          } else {
            return other;
          }
      }
    });
    return `${options.delimiter}${body}${options.delimiter}`;
  };

  unicodeCodePointToUnicodeEscapes = function(codePoint) {
    var high, low, toUnicodeEscape;
    toUnicodeEscape = function(val) {
      var str;
      str = val.toString(16);
      return `\\u${repeat('0', 4 - str.length)}${str}`;
    };
    if (codePoint < 0x10000) {
      return toUnicodeEscape(codePoint);
    }
    // surrogate pair
    high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
    low = (codePoint - 0x10000) % 0x400 + 0xDC00;
    return `${toUnicodeEscape(high)}${toUnicodeEscape(low)}`;
  };

  // Replace `\u{...}` with `\uxxxx[\uxxxx]` in regexes without `u` flag
  exports.replaceUnicodeCodePointEscapes = function(str, {flags, error, delimiter = ''} = {}) {
    var shouldReplace;
    shouldReplace = (flags != null) && indexOf.call(flags, 'u') < 0;
    return str.replace(UNICODE_CODE_POINT_ESCAPE, function(match, escapedBackslash, codePointHex, offset) {
      var codePointDecimal;
      if (escapedBackslash) {
        return escapedBackslash;
      }
      codePointDecimal = parseInt(codePointHex, 16);
      if (codePointDecimal > 0x10ffff) {
        error("unicode code point escapes greater than \\u{10ffff} are not allowed", {
          offset: offset + delimiter.length,
          length: codePointHex.length + 4
        });
      }
      if (!shouldReplace) {
        return match;
      }
      return unicodeCodePointToUnicodeEscapes(codePointDecimal);
    });
  };

  UNICODE_CODE_POINT_ESCAPE = /(\\\\)|\\u\{([\da-fA-F]+)\}/g; // Make sure the escape isn’t escaped.

}).call(this);
