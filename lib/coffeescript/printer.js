// Generated by CoffeeScript 2.3.2
(function() {
  var BLOCK, CodeFragment, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, PRECEDENCE, PRECEDENCE_LEVELS, SIMPLENUM, TAB, _dump, asStatement, compact, del, dump, extend, flatten, fragmentize, fragmentsToText, fronts, getPrecedence, i, indent, isClass, isString, j, k, leadsWithObject, len, len1, makeCode, merge, needsParens, nodeFragmentsToText, nodePrint, nodePrinted, op, print, printArray, printAssignment, printBinaryExpression, printBlock, printCall, printClass, printFunction, printObject, printParams, printSplat, printStatementSequence, printer, push, tier, unshift, wrapInBraces,
    indexOf = [].indexOf;

  ({
    merge,
    dump: _dump,
    extend,
    isString,
    del,
    flatten,
    compact
  } = require('./helpers'));

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref;
      this.code = `${code}`;
      this.type = (parent != null ? (ref = parent.constructor) != null ? ref.name : void 0 : void 0) || 'unknown';
      this.locationData = (parent != null ? parent.loc : void 0) ? {
        first_line: parent.loc.start.line - 1,
        first_column: parent.loc.start.column,
        last_line: parent.loc.end.line - 1,
        first_column: parent.loc.end.column,
        range: parent.range
      } : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }

    toString() {
      // This is only intended for debugging.
      return `${this.code}${(this.locationData ? ": " + locationDataToString(this.locationData) : '')}`;
    }

  };

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fragments.length; j < len; j++) {
        fragment = fragments[j];
        results.push(fragment.code);
      }
      return results;
    })()).join('');
  };

  printStatementSequence = function(body, o) {
    var index, j, len, prevWasDirective, results, stmt;
    prevWasDirective = false;
    results = [];
    for (index = j = 0, len = body.length; j < len; index = ++j) {
      stmt = body[index];
      if (index && o.spaced && !prevWasDirective) {
        this.push('\n');
      }
      this.print(stmt, merge(o, {
        spaced: false,
        asStatement: true,
        level: LEVEL_TOP
      }));
      results.push(prevWasDirective = stmt.type === 'Directive');
    }
    return results;
  };

  BLOCK = [
    'IfStatement',
    'ForStatement',
    'ForInStatement',
    'ForOfStatement',
    'WhileStatement',
    'ClassDeclaration',
    'TryStatement',
    'SwitchStatement',
    'ClassMethod' //, 'FunctionDeclaration'
  ];

  asStatement = function(fragments, o) {
    var ref;
    fragments.unshift(o.indent);
    if (ref = this.type, indexOf.call(BLOCK, ref) < 0) {
      fragments.push(';');
    }
    fragments.push('\n');
    return fragments;
  };

  wrapInBraces = function(o) {
    this.unshift('{');
    return this.push('}');
  };

  printAssignment = function(o) {
    var ref;
    this.print(this.left, o, LEVEL_LIST);
    this.push(` ${(ref = this.operator) != null ? ref : '='} `);
    return this.print(this.right, o, LEVEL_LIST);
  };

  printObject = function(o) {
    var index, isCompact, j, k, len, len1, prop, ref, ref1, shorthand, type;
    isCompact = true;
    ref = this.properties;
    for (j = 0, len = ref.length; j < len; j++) {
      ({type, shorthand} = ref[j]);
      if (!(type === 'ObjectProperty' && !shorthand)) {
        continue;
      }
      isCompact = false;
      break;
    }
    if (!isCompact) {
      this.push('\n');
    }
    ref1 = this.properties;
    for (index = k = 0, len1 = ref1.length; k < len1; index = ++k) {
      prop = ref1[index];
      if (index) {
        this.push(',');
        this.push(isCompact ? ' ' : '\n');
      }
      if (!isCompact) {
        this.push(o.indent + TAB);
      }
      this.print(prop, isCompact ? o : indent(o));
    }
    if (!isCompact) {
      this.push('\n' + o.indent);
    }
    return this.wrapInBraces();
  };

  fronts = function(o) {
    return merge(o, {
      keepFront: true
    });
  };

  printBinaryExpression = function(o) {
    this.print(this.left, fronts(o), LEVEL_OP);
    this.push(` ${this.operator} `);
    return this.print(this.right, o, LEVEL_OP);
  };

  printCall = function(o) {
    var arg, index, isNew, j, len, ref;
    isNew = this.type === 'NewExpression';
    if (isNew) {
      this.push('new ');
    }
    this.print(this.callee, isNew ? o : fronts(o), LEVEL_ACCESS);
    this.push('(');
    ref = this.arguments;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      arg = ref[index];
      if (index) {
        this.push(', ');
      }
      this.print(arg, o, LEVEL_LIST);
    }
    return this.push(')');
  };

  printArray = function(o) {
    var closingNewline, element, elements, index, j, lastIndex, len, printElements, separator, shouldBreak;
    if (!this.elements.length) {
      return this.push('[]');
    }
    this.push('[');
    printElements = () => {
      var element, index, j, len, ref, results;
      ref = this.elements;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        element = ref[index];
        if (element) {
          results.push(this.printed(element, o));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    elements = printElements();
    shouldBreak = indexOf.call(fragmentsToText(compact(flatten(elements))), '\n') >= 0;
    if (shouldBreak) {
      closingNewline = '\n' + o.indent;
      o = indent(o);
      elements = printElements();
      this.push('\n' + o.indent);
    }
    separator = shouldBreak ? ',\n' + o.indent : ', ';
    lastIndex = elements.length - 1;
    for (index = j = 0, len = elements.length; j < len; index = ++j) {
      element = elements[index];
      if (index) {
        this.push(separator);
      }
      if (element) {
        this.push(element);
      }
      if (index === lastIndex && !element) {
        this.push(', ');
      }
    }
    if (closingNewline != null) {
      this.push(closingNewline);
    }
    return this.push(']');
  };

  printParams = function(o) {
    var index, j, len, param, ref;
    this.push('(');
    ref = this.params;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      param = ref[index];
      if (index) {
        this.push(', ');
      }
      this.print(param);
    }
    return this.push(') ');
  };

  printBlock = function(o) {
    if (!(this.body.length || this.directives.length)) {
      return this.push('{}');
    }
    this.push('{');
    this.push('\n');
    this.printStatementSequence([...this.directives, ...this.body], indent(o));
    return this.push(o.indent + '}');
  };

  printSplat = function(o) {
    this.push('...');
    return this.print(this.argument, o, LEVEL_OP);
  };

  printClass = function(o) {
    this.push('class');
    if (this.id) {
      this.push(' ');
      this.print(this.id);
    }
    if (this.superClass) {
      this.push(' extends ');
      this.print(this.superClass);
    }
    if (this.body) {
      this.push(' ');
      return this.print(this.body);
    }
  };

  printFunction = function(o) {
    if (this.async) {
      this.push('async ');
    }
    this.push('function');
    if (this.generator) {
      this.push('*');
    }
    // if @id
    //   @push ' '
    //   @print @id
    this.printParams(o);
    return this.print(this.body);
  };

  printer = {
    File: function(o) {
      o.indent = o.bare ? '' : TAB;
      o.spaced = true;
      return this.print(this.program);
    },
    Program: function(o) {
      return this.printStatementSequence([...this.directives, ...this.body], o);
    },
    VariableDeclaration: function(o) {
      var declaration, indented, index, j, leadingSpace, len, ref, results;
      this.push('var ');
      ref = this.declarations;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        declaration = ref[index];
        if (declaration.init && index) {
          indented = indent(o);
          leadingSpace = '\n' + indented.indent;
        } else {
          leadingSpace = ' ';
        }
        if (index) {
          this.push(',' + leadingSpace);
        }
        results.push(this.print(declaration, indented != null ? indented : o));
      }
      return results;
    },
    VariableDeclarator: function(o) {
      this.print(this.id);
      if (this.init) {
        this.push(' = ');
        return this.print(this.init);
      }
    },
    ExpressionStatement: function(o) {
      return this.print(this.expression, merge(o, {
        setFront: true
      }));
    },
    AssignmentExpression: printAssignment,
    AssignmentPattern: printAssignment,
    Identifier: function(o) {
      return this.push(this.name);
    },
    NumericLiteral: function(o) {
      return this.push(this.extra.raw);
    },
    StringLiteral: function(o) {
      return this.push(this.extra.raw);
    },
    RegExpLiteral: function(o) {
      return this.push(this.extra.raw);
    },
    DirectiveLiteral: function(o) {
      return this.push(this.extra.raw);
    },
    BooleanLiteral: function(o) {
      return this.push(this.value ? 'true' : 'false');
    },
    NullLiteral: function(o) {
      return this.push('null');
    },
    PassthroughLiteral: function(o) {
      return this.push(this.value);
    },
    ThisExpression: function(o) {
      return this.push('this');
    },
    Super: function(o) {
      return this.push('super');
    },
    NewExpression: printCall,
    CallExpression: printCall,
    FunctionExpression: printFunction,
    // FunctionDeclaration: printFunction
    ArrowFunctionExpression: function(o) {
      if (this.async) {
        this.push('async ');
      }
      this.printParams(o);
      this.push('=> ');
      return this.print(this.body);
    },
    ClassMethod: function(o) {
      if (this.static) {
        this.push('static ');
      }
      if (this.async) {
        this.push('async ');
      }
      if (this.generator) {
        this.push('*');
      }
      if (this.computed) {
        this.push('[');
      }
      this.print(this.key);
      if (this.computed) {
        this.push(']');
      }
      this.printParams(o);
      return this.print(this.body);
    },
    BlockStatement: printBlock,
    ReturnStatement: function(o) {
      this.push('return');
      if (this.argument) {
        this.push(' ');
        return this.print(this.argument, o, LEVEL_PAREN);
      }
    },
    MemberExpression: function(o) {
      var property;
      this.print(this.object, fronts(o), LEVEL_ACCESS);
      property = this.printed(this.property, o);
      if (SIMPLENUM.test(this.fragmentsToText())) {
        this.push('.');
      }
      if (this.computed) {
        return this.push('[', property, ']');
      } else {
        return this.push('.', property);
      }
    },
    ObjectPattern: printObject,
    ObjectExpression: printObject,
    ObjectProperty: function(o) {
      var value;
      value = this.printed(this.value, o);
      if (this.shorthand) {
        return this.push(value);
      }
      if (this.computed) {
        this.push('[');
      }
      this.print(this.key);
      if (this.computed) {
        this.push(']');
      }
      this.push(': ');
      return this.push(value);
    },
    ArrayExpression: printArray,
    ArrayPattern: printArray,
    TemplateLiteral: function(o) {
      var expression, index, j, len, quasi, ref;
      this.push('`');
      ref = this.quasis;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        quasi = ref[index];
        this.print(quasi);
        expression = this.expressions[index];
        if (expression) {
          this.push('${');
          this.print(expression);
          this.push('}');
        }
      }
      return this.push('`');
    },
    TemplateElement: function(o) {
      return this.push(this.value.raw);
    },
    ForStatement: function(o) {
      this.push('for (');
      this.print(this.init);
      this.push('; ');
      this.print(this.test);
      this.push('; ');
      this.print(this.update);
      this.push(') ');
      return this.print(this.body);
    },
    ForInStatement: function(o) {
      this.push('for (');
      this.print(this.left);
      this.push(' in ');
      this.print(this.right);
      this.push(') ');
      return this.print(this.body);
    },
    ForOfStatement: function(o) {
      this.push('for ');
      if (this.await) {
        this.push('await ');
      }
      this.push('(');
      this.print(this.left);
      this.push(' of ');
      this.print(this.right);
      this.push(') ');
      return this.print(this.body);
    },
    SequenceExpression: function(o) {
      var expression, index, j, len, ref, results;
      ref = this.expressions;
      results = [];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        expression = ref[index];
        if (index) {
          this.push(', ');
        }
        results.push(this.print(expression));
      }
      return results;
    },
    BinaryExpression: printBinaryExpression,
    LogicalExpression: printBinaryExpression,
    UnaryExpression: function(o) {
      this.push(this.operator);
      if (/[a-z]$/.test(this.operator)) {
        this.push(' ');
      }
      return this.print(this.argument, o, LEVEL_OP);
    },
    UpdateExpression: function(o) {
      if (this.prefix) {
        this.push(this.operator);
      }
      this.print(this.argument, this.prefix ? o : fronts(o));
      if (!this.prefix) {
        return this.push(this.operator);
      }
    },
    IfStatement: function(o) {
      this.push('if (');
      this.print(this.test);
      this.push(') ');
      this.print(this.consequent);
      if (this.alternate) {
        this.push(' else ');
        return this.print(this.alternate);
      }
    },
    ConditionalExpression: function(o) {
      this.print(this.test, o, LEVEL_COND);
      this.push(' ? ');
      this.print(this.consequent, o, LEVEL_LIST);
      this.push(' : ');
      return this.print(this.alternate, o, LEVEL_LIST);
    },
    ContinueStatement: function(o) {
      return this.push('continue');
    },
    BreakStatement: function(o) {
      return this.push('break');
    },
    AwaitExpression: function(o) {
      this.push('await ');
      return this.print(this.argument, o, LEVEL_OP);
    },
    YieldExpression: function(o) {
      this.push('yield');
      if (this.delegate) {
        this.push('*');
      }
      if (this.argument) {
        this.push(' ');
        return this.print(this.argument, o, LEVEL_OP);
      }
    },
    SwitchStatement: function(o) {
      var j, kase, len, ref;
      this.push('switch (');
      this.print(this.discriminant);
      this.push(') {\n');
      ref = this.cases;
      for (j = 0, len = ref.length; j < len; j++) {
        kase = ref[j];
        this.print(kase, indent(o));
      }
      return this.push(o.indent + '}');
    },
    SwitchCase: function(o) {
      this.push(o.indent);
      if (this.test) {
        this.push('case ');
        this.print(this.test);
      } else {
        this.push('default');
      }
      this.push(':');
      this.push('\n');
      return this.printStatementSequence(this.consequent, indent(o));
    },
    TryStatement: function(o) {
      this.push('try ');
      this.print(this.block);
      if (this.handler) {
        this.push(' ');
        this.print(this.handler);
      }
      if (this.finalizer) {
        this.push(' finally ');
        return this.print(this.finalizer);
      }
    },
    CatchClause: function(o) {
      this.push('catch (');
      this.print(this.param);
      this.push(') ');
      return this.print(this.body);
    },
    ThrowStatement: function(o) {
      this.push('throw ');
      return this.print(this.argument, o, LEVEL_LIST);
    },
    ClassExpression: printClass,
    ClassDeclaration: printClass,
    ClassBody: function(o) {
      return printBlock.call(this, merge(o, {
        spaced: true
      }));
    },
    SpreadElement: printSplat,
    RestElement: printSplat,
    WhileStatement: function(o) {
      this.push('while (');
      this.print(this.test);
      this.push(') ');
      return this.print(this.body);
    },
    TaggedTemplateExpression: function(o) {
      this.print(this.tag);
      return this.print(this.quasi);
    },
    ImportDeclaration: function(o) {
      var indented, index, j, k, l, leading, len, len1, len2, named, ref, ref1, specifier;
      this.push('import ');
      leading = [];
      named = [];
      if (this.specifiers) {
        if (this.specifiers.length) {
          ref = this.specifiers;
          for (j = 0, len = ref.length; j < len; j++) {
            specifier = ref[j];
            ((ref1 = specifier.type) === 'ImportDefaultSpecifier' || ref1 === 'ImportNamespaceSpecifier' ? leading : named).push(specifier);
          }
          for (index = k = 0, len1 = leading.length; k < len1; index = ++k) {
            specifier = leading[index];
            if (index) {
              this.push(', ');
            }
            this.print(specifier);
          }
          if (named.length) {
            if (leading.length) {
              this.push(', ');
            }
            indented = indent(o);
            this.push('{\n' + indented.indent);
            for (index = l = 0, len2 = named.length; l < len2; index = ++l) {
              specifier = named[index];
              if (index) {
                this.push(',\n' + indented.indent);
              }
              this.print(specifier, indented);
            }
            this.push('\n' + o.indent + '}');
          }
        } else {
          this.push('{}');
        }
        this.push(' from ');
      }
      return this.print(this.source);
    },
    ImportDefaultSpecifier: function(o) {
      return this.print(this.local);
    },
    ImportNamespaceSpecifier: function(o) {
      this.push('* as ');
      return this.print(this.local);
    },
    ImportSpecifier: function(o) {
      this.print(this.imported);
      if (this.local.name !== this.imported.name) {
        this.push(' as ');
        return this.print(this.local);
      }
    },
    ExportNamedDeclaration: function(o) {
      var indented, index, j, len, ref, specifier;
      this.push('export ');
      if (this.specifiers.length) {
        indented = indent(o);
        this.push('{\n' + indented.indent);
        ref = this.specifiers;
        for (index = j = 0, len = ref.length; j < len; index = ++j) {
          specifier = ref[index];
          if (index) {
            this.push(',\n' + indented.indent);
          }
          this.print(specifier, indented);
        }
        this.push('\n' + o.indent + '}');
      } else if (this.declaration) {
        this.print(this.declaration);
      } else {
        this.push('{}');
      }
      if (this.source) {
        this.push(' from ');
        return this.print(this.source);
      }
    },
    ExportDefaultDeclaration: function(o) {
      this.push('export default ');
      return this.print(this.declaration);
    },
    ExportAllDeclaration: function(o) {
      this.push('export * from ');
      return this.print(this.source);
    },
    ExportSpecifier: function(o) {
      this.print(this.local);
      if (this.local.name !== this.exported.name) {
        this.push(' as ');
        return this.print(this.exported);
      }
    },
    Directive: function(o) {
      return this.print(this.value);
    },
    JSXElement: function(o) {
      var child, j, len, ref;
      this.print(this.openingElement);
      if (this.openingElement.selfClosing) {
        return;
      }
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        this.print(child);
      }
      return this.print(this.closingElement);
    },
    JSXOpeningElement: function(o) {
      var attribute, j, len, ref;
      this.push('<');
      this.print(this.name);
      if (this.attributes.length) {
        ref = this.attributes;
        for (j = 0, len = ref.length; j < len; j++) {
          attribute = ref[j];
          this.push(' ');
          this.print(attribute);
        }
      }
      if (this.selfClosing) {
        this.push(' />');
        return;
      }
      return this.push('>');
    },
    JSXClosingElement: function(o) {
      this.push('</');
      this.print(this.name);
      return this.push('>');
    },
    JSXIdentifier: function(o) {
      return this.push(this.name);
    },
    JSXAttribute: function(o) {
      this.print(this.name);
      if (this.value) {
        this.push('=');
        return this.print(this.value);
      }
    },
    JSXExpressionContainer: function(o) {
      this.push('{');
      this.print(this.expression);
      return this.push('}');
    },
    JSXText: function(o) {
      return this.push(this.value);
    },
    JSXSpreadAttribute: function(o) {
      this.push('{...');
      this.print(this.argument);
      return this.push('}');
    },
    JSXFragment: function(o) {
      var child, j, len, ref;
      this.print(this.openingFragment);
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        this.print(child);
      }
      return this.print(this.closingFragment);
    },
    JSXOpeningFragment: function(o) {
      return this.push('<>');
    },
    JSXClosingFragment: function(o) {
      return this.push('</>');
    }
  };

  makeCode = function(code) {
    return new CodeFragment(this, code);
  };

  fragmentize = function(fragments, node) {
    var fragment, j, len, results;
    results = [];
    for (j = 0, len = fragments.length; j < len; j++) {
      fragment = fragments[j];
      if (isString(fragment)) {
        results.push(node.makeCode(fragment));
      } else {
        results.push(fragment);
      }
    }
    return results;
  };

  nodePrinted = function(node, o, level) {
    var keepFront, printed, setFront;
    keepFront = del(o, 'keepFront');
    setFront = del(o, 'setFront');
    if (level) {
      o = merge(o, {level});
    }
    o = merge(o, {
      front: setFront ? true : keepFront ? o.front : false
    });
    // return flatten(@print child, o for child in node) if Array.isArray node
    node.parent = this;
    printed = fragmentize(print(node, o), node);
    if (!needsParens(node, o)) {
      return printed;
    }
    return [node.makeCode('('), ...printed, node.makeCode(')')];
  };

  nodePrint = function(defaultOpts) {
    return function(node, o = defaultOpts, level) {
      return this.push(this.printed(node, o, level));
    };
  };

  push = function(...fragments) {
    return this.fragments.push(...fragments);
  };

  unshift = function(...fragments) {
    return this.fragments.unshift(...fragments);
  };

  nodeFragmentsToText = function() {
    return fragmentsToText(flatten(this.fragments));
  };

  exports.print = print = function(node, o) {
    var _asStatement, printed;
    _asStatement = del(o, 'asStatement');
    extend(node, {
      makeCode,
      printStatementSequence,
      wrapInBraces,
      asStatement,
      printParams,
      printed: nodePrinted,
      print: nodePrint(o),
      fragments: [],
      push,
      unshift,
      fragmentsToText: nodeFragmentsToText
    });
    if (!printer[node.type]) {
      // node.tab = o.indent
      console.log({
        missing: node
      });
    }
    printed = printer[node.type].call(node, o);
    printed = flatten(node.fragments);
    if (!_asStatement) {
      return printed;
    }
    return node.asStatement(printed, o);
  };

  indent = function(o) {
    return merge(o, {
      indent: o.indent + TAB
    });
  };

  TAB = '  ';

  SIMPLENUM = /^[+-]?\d+$/;

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  PRECEDENCE = {};

  PRECEDENCE_LEVELS = [["|>"], ["||", "??"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]];

  for (i = j = 0, len = PRECEDENCE_LEVELS.length; j < len; i = ++j) {
    tier = PRECEDENCE_LEVELS[i];
    for (k = 0, len1 = tier.length; k < len1; k++) {
      op = tier[k];
      PRECEDENCE[op] = i;
    }
  }

  getPrecedence = function(op) {
    return PRECEDENCE[op];
  };

  leadsWithObject = function(node) {
    while (node.type === 'MemberExpression') {
      if (node.object.type === 'ObjectExpression') {
        return true;
      }
      node = node.object;
    }
  };

  isClass = function({type}) {
    return type === 'ClassExpression' || type === 'ClassDeclaration';
  };

  needsParens = function(node, o) {
    var level, parent, ref, ref1, type;
    ({type, parent} = node);
    ({level} = o);
    if (o.front && ((type === 'FunctionExpression' || type === 'ObjectExpression') || type === 'AssignmentExpression' && (node.left.type === 'ObjectPattern' || node.left.type === 'MemberExpression' && leadsWithObject(node.left)))) {
      return true;
    }
    switch (type) {
      case 'AssignmentExpression':
        if (level > LEVEL_LIST) {
          return true;
        }
        if (node.left.type === 'ObjectPattern') {
          return true;
        }
        switch (parent.type) {
          case 'ReturnStatement':
            return true;
        }
        break;
      case 'FunctionExpression':
      case 'ArrowFunctionExpression':
        if (level >= LEVEL_ACCESS) {
          return true;
        }
        break;
      case 'BinaryExpression':
      case 'LogicalExpression':
        if (((ref = parent.type) === 'BinaryExpression' || ref === 'LogicalExpression') && (function() {
          var associatesLeft, isLeft, nodePrecedence, parentPrecedence;
          isLeft = node === parent.left;
          associatesLeft = node.operator !== '**';
          if (node.operator === parent.operator) {
            if (isLeft && associatesLeft) {
              return false;
            }
            if (!isLeft && !associatesLeft) {
              return false;
            }
            return true;
          }
          nodePrecedence = getPrecedence(node.operator);
          parentPrecedence = getPrecedence(parent.operator);
          if (!((nodePrecedence != null) && (parentPrecedence != null))) {
            return true;
          }
          return nodePrecedence < parentPrecedence;
        })()) {
          return true;
        }
        if (parent.type === 'UnaryExpression') {
          return true;
        }
        break;
      case 'UnaryExpression':
        if (parent.type === 'BinaryExpression' && parent.operator === '**') {
          return true;
        }
        if (((ref1 = node.operator) === '+' || ref1 === '-') && parent.type === 'UnaryExpression' && parent.operator === node.operator) {
          return true;
        }
        break;
      case 'UpdateExpression':
        if (node.prefix && parent.type === 'UnaryExpression' && (node.operator === '++' && parent.operator === '+' || node.operator === '--' && parent.operator === '-')) {
          return true;
        }
        break;
      case 'AwaitExpression':
      case 'YieldExpression':
        if (level >= LEVEL_PAREN) {
          return true;
        }
        break;
      case 'ConditionalExpression':
        if (level >= LEVEL_COND) {
          return true;
        }
        break;
      case 'SequenceExpression':
        if (level >= LEVEL_PAREN) {
          return true;
        }
        break;
      case 'CallExpression':
        if (parent.type === 'NewExpression' && node === parent.callee) {
          return true;
        }
        break;
      case 'ClassExpression':
        if (level >= LEVEL_ACCESS) {
          return true;
        }
        if (isClass(parent) && node === parent.superClass) {
          return true;
        }
    }
  };

  dump = function(obj) {
    return _dump(merge(obj, {
      parent: null
    }));
  };

}).call(this);
